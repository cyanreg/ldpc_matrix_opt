/*
 * This file is part of ldpc_matrix_opt.
 *
 * ldpc_matrix_opt is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * ldpc_matrix_opt is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with ldpc_matrix_opt; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
 */

uint32_t pcg_hash(uint32_t state)
{
    state *= 747796405;
    state += 2891336453;
    uint32_t word = ((state >> ((state >> 28) + 4)) ^ state) * 277803737;
    return (word >> 22) ^ word;
}

void fill_buffer(OctetBuffer pkt)
{
    uint64_t dst = uint64_t(pkt);
    uint32_t state = 0xDEADBEEF + 1;

    for (int i = 0; i < (message_bits >> 8); i += 4) {
        state = pcg_hash(state);
        OctetBuffer(dst).b[0] = uint8_t((state >>  0) & 0xFF);
        OctetBuffer(dst).b[1] = uint8_t((state >>  8) & 0xFF);
        OctetBuffer(dst).b[2] = uint8_t((state >> 16) & 0xFF);
        OctetBuffer(dst).b[3] = uint8_t((state >> 24) & 0xFF);
        dst += 4;
    }
}

void ldpc_encode(OctetBuffer pkt, MatrixBuffer H)
{
    int i, j, k;
    uint64_t parity, data, bits[8];

    /* Parity data goes last */
    uint64_t dst = uint64_t(pkt) + (message_bits >> 3);
    uint64_t src = uint64_t(H);

    /* Process 64 rows at a time */
    for (i = 0; i < (parity_bits >> 6); i++) {
        parity = 0x0; /* Start with zero parity */

        /* Process 8 data bits at a time */
        for (j = 0; j < (message_bits >> 3); j++) {
            data = pkt.b[j];

            /* Duplicate each bit 64 times (reversed, bytestream order) */
            for (k = 0; k < 8; k++) {
                bits[k] = bool((data >> (7 - k)) & 1) ? ~0 : 0;
            }

            /* Add each bit to a parity bit, according to the matrix */
            for (k = 0; k < 8; k++) {
                parity ^= bits[k] & (MatrixBuffer(src).v[0]);
                src += 64;
            }
        }

        /* Write parity data, in bytestream order */
        for (k = 56; k >= 0; k -= 8) {
            OctetBuffer(dst).b[0] = uint8_t((parity >> k) & 0xFF);
            dst += 1;
        }

        /* Skip identity elements in the matrix */
        src += parity_bits;
    }
}

void main()
{
    fill_buffer(msg_base);
    ldpc_encode(msg_base, mat_base);
}
